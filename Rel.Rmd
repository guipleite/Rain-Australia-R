---
title: "Predizendo Chuva na Australia"
output: html_document
---

```{r include=FALSE}
# install.packages("gmodels")
# install.packages("ggthemes")
# install.packages("ggmap")
# install.packages("sf")
# install.packages("mapview")
# install.packages("ggrepel")
# install.packages("lobstr")
# install.packages("mapproj")
# install.packages("dummies")
# install.packages('caTools')
# install.packages('randomForest')
# install.packages('precrec')

library(tidyverse)
library(gmodels)
library(ggthemes)
library(ggrepel)
library(sf)
library(mapview)
library(ggmap)
library(dummies)
library(caTools)
library(randomForest)
library(precrec)

```
<div style="text-align:center"><img src="./Aus_fire.jpg" alt="drawing" width=50% /></div><div style="text-align:center" >Matthew Abbott / The New York Times</div><b/><br/>


### Introdução 

Os incêndios florestais na Austrália são uma ocorrência regular que teve um papel significativo na formação da natureza do continente ao longo de milhões de anos. No entanto, os incêndios podem causar danos materiais significativos e levar à perda de vidas humanas e animais. Os incêndios florestais mataram cerca de 800 pessoas e bilhões de animais desde 1851. Estima-se que entre 2019 e 2020 os incêndios mataram pelo menos 33 pessoas e mais de 3 bilhões de animais.

Geralmente, os incêndios mais devastadores são precedidos por altas temperaturas, baixa umidade relativa e fortes ventos, que criam as condições ideais para a rápida propagação do fogo. A chuva é a maior aliada ao combate ao fogo e na mitigação do surgimento de novos de focos de incêndios. Outro problema que agrava a situação na Austrália, é a forte dependência do país de civis para conter seus incêndios, cerca de 90% dos bombeiros combatendo fogos florestais são voluntários. 

Portanto, considerando os recursos limitados para combate aos incêndios florestais, ainda mais com o aumento das mudanças climáticas que estão tornando esses eventos mais frequentes e devastadores, saber se irá chover em uma região específica dadas algumas medições é importante para direcionar os esforços onde eles são mais necessários. 

### Visualizando os Dados 

```{r}
dataset = tibble(read.csv('weatherAUS.csv'))
print(dataset)
```

#### Mapa com as Temperaturas Máximas de Cada Local 

Usando a API do Google Maps para salvar as coordenadas geográficas de cada local de medição, como existem vários lugares com o mesmo nome em diferentes países anglófonos, é necessário concatenar o nome do país no final do local para garantir que as coordenadas estarão coerentes. 
```{r}
MTemp <- dataset[!is.na(dataset$MaxTemp), ] %>%
  select(Location, MaxTemp)

TempLocation <- aggregate(MTemp$MaxTemp, by=list(Category=MTemp$Location), FUN=mean)
TempLocation$Category <- paste(TempLocation$Category, ", Australia")# Adding Australia to the end of location name since there are many cities with the same names in other countries

```

```{r message=FALSE}
cities_df <- as.data.frame(TempLocation)
locations_df <- mutate_geocode(cities_df, Category)
locations <- as_tibble(locations_df)

locations_sf <- st_as_sf(locations, coords = c("lon", "lat"), crs = 4326)

```

```{r warning=FALSE}
aus_coord <- geocode("Australia")

map <- get_googlemap(center = c(aus_coord$lon, aus_coord$lat), zoom = 4)


ggmap(map) +
  geom_point(data = locations,
             aes(x = lon, y = lat, size = x),
             color = "red", alpha = 0.3)
```

#### Mapa de Calor de Pluvialidade

```{r}
RF <- dataset[!is.na(dataset$Rainfall), ] %>%
  select(Location, Rainfall)

RainLocation <- aggregate(RF$Rainfall, by=list(Category=RF$Location), FUN=sum)
RainLocation$Category <- paste(RainLocation$Category, ", Australia")# Adding Australia to the end of location name since there are many cities with the same names in other countries

```

```{r message=FALSE}
Rcities_df <- as.data.frame(RainLocation)
Rlocations_df <- mutate_geocode(Rcities_df, Category)
Rlocations <- as_tibble(Rlocations_df)

Rlocations_sf <- st_as_sf(Rlocations, coords = c("lon", "lat"), crs = 4326)
print(Rlocations_sf)

```

```{r warning=FALSE}
YlOrBr <- c("#FFFFD4", "#FED98E", "#FE9929", "#D95F0E", "#993404")

ggmap(map) +
  stat_density_2d(
    data = Rlocations,
    aes(x = lon, y = lat, fill = stat(x)),
    alpha = .1,
    bins = 30,
    geom = "polygon"
  ) +
  scale_fill_gradientn(colors = YlOrBr)

```

### Média de Precipitação por Mês

```{r}
RD <- dataset[!is.na(dataset$Rainfall), ] %>%
  select(Date, Rainfall)

# substring(RD$Date,6,7) # Month only
RainMonth = aggregate(RD$Rainfall, by=list(Category=substring(RD$Date,6,7)), FUN=mean) # Mean Rainfall by month

```


```{r}
ggplot(data=RainMonth, aes(x=Category, y=x, group=1)) +
  geom_line()+
  geom_point()

```


### Criando o modelo

#### Removendo colunas com muitos dados faltando e depois removendo entradas incompletas. 
```{r}
print(colMeans(is.na(dataset))) # Percentage of missing data in each column

datasetClean <- subset(dataset, select=-c(Evaporation, Sunshine, Cloud9am, Cloud3pm, Date)) # Removing features with high NA precentage
datasetClean <- datasetClean[complete.cases(datasetClean), ] # Removing NAs

```

#### One-Hot encoding nas features categóricas.

```{r warning=FALSE}

WD3<-dummy(datasetClean$WindDir3pm)
WD9<-dummy(datasetClean$WindDir9am)
WGD<-dummy(datasetClean$WindGustDir)
Loc<-dummy(datasetClean$Location)

colnames(WD3) <- paste("WindDir3pm", colnames(WD3), sep = "_")
colnames(WD9) <- paste("WindDir9am", colnames(WD9), sep = "_")
colnames(WGD) <- paste("WindGustDir", colnames(WGD), sep = "_")
colnames(Loc) <- paste("Location", colnames(Loc), sep = "_")

datasetD <- cbind(datasetClean, WD3)
datasetD <- cbind(datasetD, WD9)
datasetD <- cbind(datasetD, WGD)
datasetD <- cbind(datasetD, Loc)


datasetD$RainToday <- factor(datasetD$RainToday,
             levels = c('No', 'Yes'),
             labels = c(0, 1))

datasetD$RainTomorrow <- factor(datasetD$RainTomorrow,
                   levels = c('No', 'Yes'),
                   labels = c(0, 1))

df<-tibble(datasetD)

```

#### Separando em datasets de treino e teste.

```{r}
set.seed(1337)
split = sample.split(df$RainTomorrow, SplitRatio = 0.8)
training_set = subset(df, split == TRUE)
test_set = subset(df, split == FALSE)
```

#### Treinando o classificador Random Forest.

```{r}
y <- training_set$RainTomorrow
X <- subset(training_set, select=-c(RainTomorrow))

classifier = randomForest(x = X,
                          y = y,
                          ntree = 100)

classifier
```

#### Matriz de confusão.

```{r}
y_pred = predict(classifier, newdata = subset(test_set, select=-c(RainTomorrow)))

# Confusion Matrix
cm = table(test_set$RainTomorrow, y_pred)
print(cm)

```

#### Calculando a acurácia do modelo.

```{r}
# Accuracy Score
accuracy = sum(y_pred == test_set$RainTomorrow) / nrow(test_set)
print(accuracy)
```

#### Visualizando as curvas de ROC e Precision e Recall.

```{r}
precrec_obj <- evalmod(scores =as.integer(y_pred), labels = test_set$RainTomorrow)
autoplot(precrec_obj)

```












